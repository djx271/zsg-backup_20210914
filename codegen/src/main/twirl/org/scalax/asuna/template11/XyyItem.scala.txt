@(maxItem: Int)

package org.scalax.asuna.ii.item

trait XyyItem0 extends Any {

    def eat[T](xyy: T): XyyItem1[T] = throw new Exception("Can not use this method.")
    def pudao[T](xyy: T): XyyItem1[T] = throw new Exception("Can not use this method.")

    def eatToTuple[T](xyy: T): Tuple1[T] = Tuple1(xyy)
    def pudaoToTuple[T](xyy: T): Tuple1[T] = Tuple1(xyy)

}

object XyyItem0 extends XyyItem0

trait XyyItem1[E1] extends Any with org.scalax.asuna.mapper.item.TagContentImpl[ItemTag1[E1]] {
    self =>

    override type IITag = ItemTag1[E1]

    def i1: E1

    def leftHead: E1 = throw new Exception("Can not use this method.")
    def leftTail: XyyItem0 = throw new Exception("Can not use this method.")
    def rightHead: E1 = throw new Exception("Can not use this method.")
    def rightTail: XyyItem0 = throw new Exception("Can not use this method.")

    def eat[T](xyy: T): XyyItem2[E1, T] = throw new Exception("Can not use this method.")
    def pudao[T](xyy: T): XyyItem2[T, E1] = throw new Exception("Can not use this method.")

    def eatToTuple[T](xyy: T): Tuple2[E1, T] = (self.i1, xyy)
    def pudaoToTuple[T](xyy: T): Tuple2[T, E1] = (xyy, self.i1)

}

@for(i <- 2 to maxItem) {

    trait XyyItem@{i}[@for(ii <- 1 to i) { E@{ii} @if(ii < i) { , } }] extends Any with org.scalax.asuna.mapper.item.TagContentImpl[ItemTag@{i}[@for(ii <- 1 to i) { E@{ii} @if(ii < i) { , } }]] {
        self =>

        override type IITag = ItemTag@{i}[@for(ii <- 1 to i) { E@{ii} @if(ii < i) { , } }]

        @for(ii <- 1 to i) {
            def i@{ii}: E@{ii}
        }

        def leftHead: E1 = throw new Exception("Can not use this method.")
        def leftTail: XyyItem@{i - 1}[@for(ii <- 2 to i) { E@{ii} @if(ii < i) { , } }] = throw new Exception("Can not use this method.")
        def rightHead: E@{i} = throw new Exception("Can not use this method.")
        def rightTail: XyyItem@{i - 1}[@for(ii <- 2 to i) { E@{ii - 1} @if(ii < i) { , } }] = throw new Exception("Can not use this method.")

        def eat[T](xyy: T): XyyItem@{i + 1}[@for(ii <- 1 to i) { E@{ii}, } T] = throw new Exception("Can not use this method.")
        def pudao[T](xyy: T): XyyItem@{i + 1}[T @for(ii <- 1 to i) { , E@{ii} }] = throw new Exception("Can not use this method.")

        def eatToTuple[T](xyy: T): Tuple@{i + 1}[@for(ii <- 1 to i) { E@{ii}, } T] = (@for(ii <- 1 to i) { self.i@{ii}, } xyy)
        def pudaoToTuple[T](xyy: T): Tuple@{i + 1}[T @for(ii <- 1 to i) { , E@{ii} }] = (xyy @for(ii <- 1 to i) { , self.i@{ii} })

        def leftTuple: Tuple@{i - 1}[@for(ii <- 2 to i) { E@{ii} @if(ii < i) { , } }] = Tuple@{i - 1}(@for(ii <- 2 to i) { self.i@{ii} @if(ii < i) { , } })
        def rightTuple: Tuple@{i - 1}[@for(ii <- 2 to i) { E@{ii - 1} @if(ii < i) { , } }] = Tuple@{i - 1}(@for(ii <- 2 to i) { self.i@{ii - 1} @if(ii < i) { , } })

    }

}

trait XyyItem@{maxItem + 1}[@for(ii <- 1 to (maxItem + 1)) { E@{ii} @if(ii < (maxItem + 1)) { , } }] extends Any with org.scalax.asuna.mapper.item.TagContentImpl[ItemTag@{maxItem + 1}[@for(ii <- 1 to (maxItem + 1)) { E@{ii} @if(ii < (maxItem + 1)) { , } }]] {
    self =>

    override type IITag = ItemTag@{maxItem + 1}[@for(ii <- 1 to (maxItem + 1)) { E@{ii} @if(ii < (maxItem + 1)) { , } }]

    @for(ii <- 1 to (maxItem + 1)) {
        def i@{ii}: E@{ii}
    }

    def leftHead: E1 = throw new Exception("Can not use this method.")
    def leftTail: XyyItem@{maxItem}[@for(ii <- 2 to (maxItem + 1)) { E@{ii} @if(ii < (maxItem + 1)) { , } }] = throw new Exception("Can not use this method.")
    def rightHead: E@{maxItem + 1} = throw new Exception("Can not use this method.")
    def rightTail: XyyItem@{maxItem}[@for(ii <- 2 to (maxItem + 1)) { E@{ii - 1} @if(ii < (maxItem + 1)) { , } }] = throw new Exception("Can not use this method.")

    def leftTuple: Tuple@{maxItem}[@for(ii <- 2 to (maxItem + 1)) { E@{ii} @if(ii < (maxItem + 1)) { , } }] = (@for(ii <- 2 to (maxItem + 1)) { self.i@{ii} @if(ii < (maxItem + 1)) { , } })
    def rightTuple: Tuple@{maxItem}[@for(ii <- 2 to (maxItem + 1)) { E@{ii - 1} @if(ii < (maxItem + 1)) { , } }] = (@for(ii <- 2 to (maxItem + 1)) { self.i@{ii - 1} @if(ii < (maxItem + 1)) { , } })

}