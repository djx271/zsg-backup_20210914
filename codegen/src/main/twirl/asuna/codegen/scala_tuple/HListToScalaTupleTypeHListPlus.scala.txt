@(maxNum: Int)

package asuna.tuple.support

@for(ii <- 2 to maxNum) {
import asuna.tuple.ScalaTupleTypeHList@{ii}
}
import asuna.TypeHList
import asuna.Plus
import asuna.support.heterogeneous._

trait HListToScalaTupleTypeHListPlus {

@for(tagNum <- 2 to maxNum) {

def plus@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} <: TypeHList @if(ii < tagNum) { , } }]: Plus[
    ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }],
    E@{tagNum},
    ScalaTupleTypeHList@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} @if(ii < tagNum) { , } }]
] =
new Plus[
    ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }],
    E@{tagNum},
    ScalaTupleTypeHList@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} @if(ii < tagNum) { , } }]
] {
override def plus(p: ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }]#H,
item: E@{tagNum}#H): ScalaTupleTypeHList@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} @if(ii < tagNum) { , } }]#H = {
val ii1 = p.head
@if(tagNum > 2) {
    val tt1 = p.tail
}
@for(i <- 2 to (tagNum - 1)) {
val ii@{i} = tt@{i - 1}.head
@if(i < (tagNum - 1)) { val tt@{i} = tt@{i - 1}.tail }
}
(@for(i <- 1 to (tagNum - 1)) { ii@{tagNum - i}, }  item)
}
override def takeTail(t: (@for(ii <- 1 to tagNum) { E@{ii}#H @if(ii < tagNum) { , } })): E@{tagNum}#H = t._@{tagNum}
override def takeHead(t: (@for(ii <- 1 to tagNum) { E@{ii}#H @if(ii < tagNum) { , } })): @for(ii <- (tagNum - 1) to 1 by - 1) { E@{ii}#H :: } HNil = @for(ii <- (tagNum - 1) to 1 by - 1) { t._@{ii} :: } HNil
override def sub: Plus[ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }]#T, E@{tagNum}#T, ScalaTupleTypeHList@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} @if(ii < tagNum) { , } }]#T] = plus@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii}#T @if(ii < tagNum) { , } }]
}

def put@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii} <: TypeHList @if(ii < tagNum) { , } }]: Plus[
    ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }],
    E@{tagNum},
    ScalaTupleTypeHList@{tagNum}[@for(ii <- tagNum to 1 by - 1) { E@{ii} @if(ii > 1) { , } }]
] =
new Plus[
        ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }],
        E@{tagNum},
        ScalaTupleTypeHList@{tagNum}[@for(ii <- tagNum to 1 by - 1) { E@{ii} @if(ii > 1) { , } }]
    ] {
override def plus(p: ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }]#H,
item: E@{tagNum}#H): ScalaTupleTypeHList@{tagNum}[@for(ii <- tagNum to 1 by - 1) { E@{ii} @if(ii > 1) { , } }]#H = {
val ii1 = p.head
@if(tagNum > 2) {
    val tt1 = p.tail
}
@for(i <- 2 to (tagNum - 1)) {
val ii@{i} = tt@{i - 1}.head
@if(i < (tagNum - 1)) { val tt@{i} = tt@{i - 1}.tail }
}
(item @for(i <- 1 to (tagNum - 1)) { , ii@{i} })
}
override def takeTail(t: (@for(ii <- tagNum to 1 by - 1) { E@{ii}#H @if(ii > 1) { , } })): E@{tagNum}#H = t._1
override def takeHead(t: (@for(ii <- tagNum to 1 by - 1) { E@{ii}#H @if(ii > 1) { , } })): @for(ii <- (tagNum - 1) to 1 by - 1) { E@{ii}#H :: } HNil = @for(ii <- 2 to tagNum) { t._@{ii} :: } HNil
override def sub: Plus[ScalaTupleHListTypeHList.ScalaTupleHListTypeHList@{tagNum - 1}[@for(ii <- 1 to (tagNum - 1)) { E@{ii} @if(ii < (tagNum - 1)) { , } }]#T, E@{tagNum}#T, ScalaTupleTypeHList@{tagNum}[@for(ii <- tagNum to 1 by - 1) { E@{ii} @if(ii > 1) { , } }]#T] = put@{tagNum}[@for(ii <- 1 to tagNum) { E@{ii}#T @if(ii < tagNum) { , } }]
}

}

}

object HListToScalaTupleTypeHListPlus extends HListToScalaTupleTypeHListPlus