项目初期构想（项目以英文为主，后续删除）
============================================================
本项目是一个数据转换的抽象，现在完成了一个很初步的例子，证明了我的设想的可行性。
但因为喵喵酱脑子笨，这个设想没有找到什么现成的理论支持，空想起来特别郁闷，建模也很难建，
所以在这里说说这个项目的一些核心思想，让各位 dalao 帮帮忙和提提意见。

#### 项目灵感完全来自于 slick 的 shape

在很久以前做一个 slick 动态 create 插件的时候就发现了一个事情，slick 的列可以被转化成迭代的
tuple2（HList），然后动态化。后来这个插件经过几次完全的重构
（已经基本可以发布[umr](https://github.com/djx314/umr)），
再加上开发了一个动态数据读写的工具（已经废了），这个项目的构想已经基本成型。

#### 表象

首先来上代码：[代码段1](https://github.com/scalax/asuna/blob/master/src/test/scala/net/scalax/asuna/circe/CirceModels.scala#L11)
，首先是`class CirceModelReader0`，没错，这段代码就是这么找打，N 年前一直延续到现在的恐惧，活生生的
slick table 声明，然后再看`class CirceModelReader1`，这个类在`CirceModelReader0`的基础上复写了 2 个方法，
加了验证逻辑。

然后是调用代码：[代码段2](https://github.com/scalax/asuna/blob/master/src/test/scala/net/scalax/asuna/circe/circe/CirceController.scala#L22)
，可见这里的 play action 用了一个 BodyParser（抄某位 dalao 的代码，暴力膜），把刚才的
`CirceModelReader0`和`CirceModelReader1`作为影响因子传入 Action，然后 2 个方法内部的 request.body 的类型判定
已经是`Student`类型了。

这个一般 play-json 库都能做的功能到底到了这里有什么不一样呢？我详细给大家分析一下。

一般的 play-json 库 + slick 的一整个逻辑的处理分为几个阶段（忽略 http 行为，只针对业务）：
* 判断请求 body 是不是 json，如果不是，返回 400
* 如果是 json，把 json decode 到 case class，如果 decode 失败，返回 400
* 如果解析成功，进行 dto 转换，或者干脆不转换直接用
* 各方面验证，如果验证失败，返回对应信息到前端，或者如果逻辑太复杂，干脆返回标准 400
* 如果验证成功，进行数据库操作，返回对应信息

而上述这个例子的话，可以看看测试用例：[代码段3](https://github.com/scalax/asuna/blob/master/src/test/scala/net/scalax/asuna/circe/circe/CirceSpec.scala#L58)  
大家可以看到，如果输入验证失败的信息，对应字段的错误信息将会被返回，其实，这段代码的实际过程如下：
* 判断请求 body 是不是 json 以及 jsonObject，如果不是，返回 400 和 json 格式的错误信息
* 如果是 jsonObject，则对每一个字段进行解析，因为字段属性本来就需要显式声明，所以可以实现类似 dto 的功能，
以及处理一些细微异构的字段。
* 在解析属性的同时，将会对`CirceModelReader1`声明的逻辑进行验证操作，支持 future 验证，也就是说，
你可以在这里验证学生姓名是否唯一这些数据库相关操作。
* 如果字段不能解析（非空字段为 null、类型不符合或其他），将会对应每一个字段返回验证失败信息。如果解析正确，
但是验证失败，则返回该字段的验证错误信息。两个阶段的信息将会一同返回前端。
* 如果所有验证信息都通过，将生成对象，进入 controller。

对比：
* dto，json decode，带逻辑验证都可以在`CirceModelReader1`内部一次性完成，得到的结果可以直接进行数据库操作。
* 验证逻辑十分灵活，支持 future 验证（当然这是附加的），不需要再在业务逻辑单独编写并且规划错误信息返回的具体格式。
* decode 的具体错误可以以可读的方式返回给前端。
* 各阶段错误一次性返回，不会出现先返回 json deocde 失败的 400 页面，再返回学号不唯一这些多阶段返回的情况。
* 都支持多字段同时参加一个验证（本来例子中没有体现，但可以实现）。  

当然，这个库的功能并不止这些，具体功能我会在最后一节说明。

#### 原理

根据十分重要的概念 type class 和 slick 的 shape 发展而来。参考一段代码：
```scala
trait Writer {
  type DataType
  val encoder: Encoder[DataType]
  val data: DataType
}
```
如果有这么一个 Writer，不管他的内部类型是什么，只要能够被实例化出来，他都能够 encode 成一个 json 对象。  

但是数据从来都是跟 Writer 分离开来处理的。所以会有下面这个结构
```scala
trait Writer {
  type DataType
  val encoder: Encoder[DataType]
}

val writers: List[Writer] = ???
val data: List[Any] = ???

def encode(writers: List[Writer], data: List[Any]): List[Json] =
  writers.zip(data).map { case (eachWriter, eachData) => eachWriter.encoder.encode(eachData) }
```

只要 writers 和 data 都遵循一定的规律，就可以顺利 encode。  
这时候问题来了，我得到的只是 List[Any]，如何变成熟悉的对象呢？这就需要 shape 了。

shape 的作用有以下几个大方面：

##### 写
* 把复杂结构的 Writer（参考 slick 的 table）转化为 List[Writer]
* 把单一的 List[Any] 格式化成对应的对象（case class）

##### 读
* 把复杂结构的 Writer（参考 slick 的 table）转化为 List[Writer]
* 把复杂的 case class 转化为你想要的 List[Any]

于是，一个类似 slick table 的数据转换的库就实现了。但用法却不止这些。

这个库主要的目的并不在 encode 和 decode 方面，而是关注于类型相同，但 type class 行为却不同的情况。

其实一个 Writer 不只有一个 encoder，一个 Writer 有 3 个部分，每个部分都可以有很多元素：
* 类型不相关的列信息，最明显的就是列名。
* 类型相关，且相同类型表现一样的信息，就是 type class 本身的概念。
* 类型相关，但表现不同的信息，例如 validator。

有了这 3 类信息，我们才可以完成上述例子的所有功能。

有了这些要素，可以先对业务逻辑创建 ast，然后封装成 Query，在生成数据的时候使用 Writers 和 shape
来读取和生成目标对象（参考 slick）。

#### 喵喵酱的计划
* 实现有层级的列和数据结构，可以切换上下文（参考 json 的对象嵌套）
* 和 poi-collection 结合实现 excel 对象的读取，甚至实现 filter，where 等功能（把 primary key
等关键数据持久到数据库）
* slick <-> json，slick <-> poi 的半动态列读取和写入。  
本情况针对有部分动态列的情景，例如一个 table，id 等几列是确定不变的，但是有一些动态列，编译时并不清楚，
可以通过 case 针对几种类型生成 column，然后建造由 column 到 column 的通道，达到例如在 sql
的控制输出列和更新列的效果，而且类型安全。
* json -> slick 的动态过滤。可以通过对字段的标记，声明哪些列可以被过滤，哪些列可以被排序，由输入的字符串
或者 json 决定。
* 以上两点的结合参考 graphql
* 解决任何变态数据验证逻辑，各类变态输出规格，甚至 case class 里面有一个 DBIO 属性你都可以用教科书式的
写法做转换。
* 分享我做的最可怕的 slick 例子（1k 行一个 query），在完全类型安全的情况下，4 个表动态
join，动态排序，动态过滤，动态列输出，多视图（json，poi）。
* 扩展：简化列声明逻辑，生成默认列声明，或者以其他奇淫手段减少代码量（例如。。。你懂得。。。）