package asuna.testkit

import asuna.tuple.ScalaTupleApplicationImplicits
import asuna.{Application, AsunaTuple0, Context, KindContext, Plus, TypeHList, TypeHList1, TypeHList2}

sealed trait TupleEncoder[T] {
  self =>
  def body(t: List[String], i: T): List[String]

  def print(t: List[String], i: T): String = {
    val ii = body(t, i)
    ii.mkString("(", ",", ")")
  }

  def ++[R](o: TupleEncoder[R]): TupleEncoder[(T, R)]

  def finalPrint(t: T): String = s"[${self.print(List.empty, t)}]"
}

trait TupleEncoder1[T] extends TupleEncoder[T] {
  self =>

  def pro(t: T): String

  override def body(t: List[String], i: T): List[String] = pro(i) :: t
  override def ++[R](o: TupleEncoder[R]): TupleEncoder[(T, R)] = new TupleEncoder2[(T, R)] {
    override def body(t: List[String], i: (T, R)): List[String] = self.pro(i._1) :: o.body(t, i._2)
  }

}

trait TupleEncoder2[T] extends TupleEncoder[T] {
  self =>

  override def body(t: List[String], i: T): List[String]
  override def ++[R](o: TupleEncoder[R]): TupleEncoder[(T, R)] = new TupleEncoder2[(T, R)] {
    override def body(t: List[String], i: (T, R)): List[String] = self.print(List.empty, i._1) :: o.body(t, i._2)
  }

}

class TupleContext[Companion] extends KindContext {
  override type M[I <: TypeHList] = TupleEncoder[I#H]
}

object tencoderContext extends Context[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)]] {

  override def isReverse: Boolean = true

  override def append[X <: TypeHList, Y <: TypeHList, Z <: TypeHList](
    x: TupleEncoder[X#H],
    y: TupleEncoder[Y#H],
    p: Plus[X, Y, Z]
  ): TupleEncoder[Z#H] = {
    val aa = y.++(x)
    new TupleEncoder2[Z#H] {
      override def body(t: List[String], i: Z#H): List[String] = aa.body(t, (p.takeTail(i), p.takeHead(i)))
    }
  }

  override def start: TupleEncoder[AsunaTuple0] = new TupleEncoder2[AsunaTuple0] {
    override def body(t: List[String], i: AsunaTuple0) = t
  }

}

object tuple {
  def asString[T, I <: TypeHList](x: T)(implicit ii: Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], T, I]): TupleEncoder[I#H] = {
    ii.application(tencoderContext)
  }
}

trait AppendTuple {
  implicit val tupleImplicit1: Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], String, TypeHList1[String]] =
    new Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], String, TypeHList1[String]] {
      override def application(context: Context[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)]]): TupleEncoder[String] = {
        new TupleEncoder1[String] {
          override def pro(t: String): String = t
        }
      }
    }

  implicit val tupleImplicit2: Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], Int, TypeHList1[Int]] =
    new Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], Int, TypeHList1[Int]] {
      override def application(context: Context[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)]]): TupleEncoder[Int] = {
        new TupleEncoder1[Int] {
          override def pro(t: Int): String = String.valueOf(t)
        }
      }
    }

  implicit val tupleImplicit3: Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], Long, TypeHList1[Long]] =
    new Application[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)], Long, TypeHList1[Long]] {
      override def application(context: Context[TupleContext[(AppendTuple, ScalaTupleApplicationImplicits)]]): TupleEncoder[Long] = {
        new TupleEncoder1[Long] {
          override def pro(t: Long): String = String.valueOf(t)
        }
      }
    }

}

object AppendTuple extends AppendTuple
