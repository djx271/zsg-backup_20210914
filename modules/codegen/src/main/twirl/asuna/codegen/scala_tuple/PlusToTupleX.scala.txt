@(tagNum: Int, caseClassNum: Int)

package asuna.scala_tuple.tuple_support

import asuna.Plus@{tagNum}

import asuna.support.heterogeneous._

trait PlusToTuple_@{caseClassNum}_@{tagNum} {

    @if(caseClassNum == 1) {
        final def plusWithTypeParameter1[X1_C1 @for(i <- 2 to tagNum) { , X@{i}_C1 }
        @for(i <- 1 to tagNum) { , Y@{i} } ]:
        Plus@{tagNum}[
            X1_C1 @for(i <- 2 to tagNum) { , X@{i}_C1 }
            @for(i <- 1 to tagNum) { , Y@{i} }
            @for(i <- 1 to tagNum) { , (Y@{i} , X@{i}_C1) }
        ] = new Plus@{tagNum}[
            X1_C1 @for(i <- 2 to tagNum) { , X@{i}_C1 }
            @for(i <- 1 to tagNum) { , Y@{i} }
            @for(i <- 1 to tagNum) { , (Y@{i} , X@{i}_C1) }
        ] {
            @for(i <- 1 to tagNum) {
                final override def takeHead@{i}(z: (Y@{i} , X@{i}_C1)): X@{i}_C1 = z._2
                final override def takeTail@{i}(z: (Y@{i} , X@{i}_C1)): Y@{i} = z._1
                final override def plus@{i}(x: X@{i}_C1, y: Y@{i}): (Y@{i} , X@{i}_C1) = (y, x)
            }
        }
    } else {
        final def plusWithTypeParameter@{caseClassNum}[X1_C1 @for(i <- 2 to caseClassNum) { , X1_C@{i} }
        @for(i <- 2 to tagNum) { @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } }
        @for(i <- 1 to tagNum) { , Y@{i} } ]:
        Plus@{tagNum}[
            @for(ii <- 1 to caseClassNum) { X1_C@{ii} :: } HNil
            @for(i <- 2 to tagNum) { , @for(ii <- 1 to caseClassNum) { X@{i}_C@{ii} :: } HNil }
            @for(i <- 1 to tagNum) { , Y@{i} }
            @for(i <- 1 to tagNum) { , ( Y@{i} @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } ) }
        ] = new Plus@{tagNum}[
            @for(ii <- 1 to caseClassNum) { X1_C@{ii} :: } HNil
            @for(i <- 2 to tagNum) { , @for(ii <- 1 to caseClassNum) { X@{i}_C@{ii} :: } HNil }
            @for(i <- 1 to tagNum) { , Y@{i} }
            @for(i <- 1 to tagNum) { , ( Y@{i} @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } ) }
        ] {
            @for(i <- 1 to tagNum) {
                final override def takeHead@{i}(z: ( Y@{i} @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } )): @for(ii <- 1 to caseClassNum) { X@{i}_C@{ii} :: } HNil =
                @for(ii <- 1 to caseClassNum) { z._@{ii + 1} :: } HNil
                final override def takeTail@{i}(z: ( Y@{i} @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } )): Y@{i} = z._1
                final override def plus@{i}(x: @for(ii <- 1 to caseClassNum) { X@{i}_C@{ii} :: } HNil, y: Y@{i}): ( Y@{i} @for(ii <- 1 to caseClassNum) { , X@{i}_C@{ii} } ) =
                (y @for(ii <- 1 to caseClassNum) { , x @for(iii <- 2 to ii) { .tail } .head })
            }
        }
    }


}